local HUI_RANGE_DEFAULT = 100

local function mcm_get(key)
	if ui_mcm and ui_mcm.get then
		return ui_mcm.get(key)
	end
	return nil
end

local function read_hui_setting_number(key, default)
	if not (ini_file and type(ini_file) == "function") then
		return default
	end
	local ini = ini_file("hui\\hui.ltx")
	if not ini then
		return default
	end
	if ini.section_exist and not ini:section_exist("settings") then
		return default
	end
	if ini.line_exist and not ini:line_exist("settings", key) then
		return default
	end
	if ini.r_float then
		local v = ini:r_float("settings", key)
		if v ~= nil then
			return v
		end
	end
	return default
end

local function read_hui_setting_bool(key, default)
	if not (ini_file and type(ini_file) == "function") then
		return default
	end
	local ini = ini_file("hui\\hui.ltx")
	if not ini then
		return default
	end
	if ini.section_exist and not ini:section_exist("settings") then
		return default
	end
	if ini.line_exist and not ini:line_exist("settings", key) then
		return default
	end
	if ini.r_bool then
		local ok, v = pcall(function()
			return ini:r_bool("settings", key)
		end)
		if ok and v ~= nil then
			return v
		end
	end
	if ini.r_string then
		local ok, v = pcall(function()
			return ini:r_string("settings", key)
		end)
		if ok and v ~= nil then
			local s = tostring(v):lower()
			if s == "1" or s == "true" or s == "yes" or s == "on" then
				return true
			end
			if s == "0" or s == "false" or s == "no" or s == "off" then
				return false
			end
		end
	end
	if ini.r_float then
		local v = ini:r_float("settings", key)
		if v ~= nil then
			return v ~= 0
		end
	end
	return default
end

local MARKER_W = 140
local MARKER_H = 44
local HEAD_Y_OFFSET_BIAS = mcm_get("hui/head_y_offset") or read_hui_setting_number("head_y_offset", 0.2)
local FOV_FACTOR_MIN = mcm_get("hui/fov_factor_min") or read_hui_setting_number("fov_factor_min", 0.1)
local FOV_FACTOR_MAX = mcm_get("hui/fov_factor_max") or read_hui_setting_number("fov_factor_max", 2)
local FOV_COMP_WEIGHT = mcm_get("hui/fov_comp_weight") or read_hui_setting_number("fov_comp_weight", 1.3)
local HP_BAR_W = mcm_get("hui/hp_bar_w") or read_hui_setting_number("hp_bar_w", 70)
local HP_BAR_MIN_W = mcm_get("hui/hp_bar_min_w") or read_hui_setting_number("hp_bar_min_w", 5)
local HP_BAR_MAX_W = mcm_get("hui/hp_bar_max_w") or read_hui_setting_number("hp_bar_max_w", 50)

local hui_range = mcm_get("hui/range") or read_hui_setting_number("range", 500)
local hui_scale = 1
local hui_ypos = 0
local show_distance = mcm_get("hui/show_distance")
if show_distance == nil then
	show_distance = read_hui_setting_bool("show_distance", true)
end
local show_name = mcm_get("hui/show_name")
if show_name == nil then
	show_name = read_hui_setting_bool("show_name", true)
end
local show_mode = mcm_get("hui/show_mode") or read_hui_setting_number("show_mode", 2)
local require_los = mcm_get("hui/require_los")
if require_los == nil then
	require_los = read_hui_setting_bool("require_los", true)
end
local show_icon = mcm_get("hui/show_icon")
if show_icon == nil then
	show_icon = read_hui_setting_bool("show_icon", true)
end

local function hui_normalize_update_ms(v)
	v = tonumber(v) or 17
	if v < 0 then
		v = 0
	elseif v > 1000 then
		v = 1000
	end
	return math.floor(v)
end

local hui_update_ms = hui_normalize_update_ms(mcm_get("hui/update_ms") or read_hui_setting_number("update_ms", 17))
local hui_last_pick_ms = nil
local hui_last_ui_ms = nil
local hui_pick_accum_ms = 0
local hui_ui_accum_ms = 0

local function hui_get_time_ms()
	if type(time_continual) == "function" then
		local ok, v = pcall(time_continual)
		if ok and v ~= nil then
			return v
		end
	end
	if type(time_global) == "function" then
		local ok, v = pcall(time_global)
		if ok and v ~= nil then
			return v
		end
	end
	if device then
		local dev = nil
		if type(device) == "function" then
			local ok, v = pcall(function()
				return device()
			end)
			if ok then
				dev = v
			end
		else
			dev = device
		end
		if dev and dev.time_global then
			local ok, v = pcall(function()
				return dev:time_global()
			end)
			if ok and v ~= nil then
				return v
			end
		end
	end
	if os and os.clock then
		local ok, v = pcall(os.clock)
		if ok and v ~= nil then
			return math.floor(v * 1000)
		end
	end
	return nil
end

local function hui_get_device_obj()
	if not device then
		return nil
	end
	if type(device) == "function" then
		local ok, v = pcall(function()
			return device()
		end)
		if ok then
			return v
		end
		return nil
	end
	return device
end

local function hui_get_dt_ms(delta)
	local d = tonumber(delta)
	if d and d > 0 then
		if d <= 1 then
			return d * 1000
		end
		return d
	end

	local dev = hui_get_device_obj()
	if not dev then
		return nil
	end

	local fdt = dev.f_time_delta
	if type(fdt) ~= "number" then
		fdt = tonumber(fdt)
	end
	if fdt and fdt > 0 then
		return fdt * 1000
	end

	local dt = dev.time_delta
	if type(dt) ~= "number" then
		dt = tonumber(dt)
	end
	if dt and dt > 0 then
		if dt <= 1 then
			return dt * 1000
		end
		return dt
	end

	return nil
end

local function hui_should_tick(accum_ms, last_ms, delta, update_ms)
	if not update_ms or update_ms <= 0 then
		return true, accum_ms, last_ms
	end

	local dt_ms = hui_get_dt_ms(delta)
	if dt_ms then
		accum_ms = accum_ms + dt_ms
		if accum_ms < update_ms then
			return false, accum_ms, last_ms
		end
		accum_ms = accum_ms - update_ms
		return true, accum_ms, last_ms
	end

	local now = hui_get_time_ms()
	if now and last_ms and (now - last_ms) < update_ms then
		return false, accum_ms, last_ms
	end
	return true, accum_ms, now or last_ms
end

local crosshair_radius_px = read_hui_setting_number("crosshair_radius_px", 35)
local hui_debug = (read_hui_setting_number("debug", 0) or 0) >= 1
local hui_debug_last_ms = 0
local hui_debug_raw_x = nil
local hui_debug_raw_y = nil
local hui_debug_mode = nil
local hui_debug_sw = nil
local hui_debug_sh = nil

local target_storage = {}
local target_dist
local target_name
local target_faction
local target_community
local target_relation
local fov_ref = nil

local monster_clsid_to_name = {
	[clsid.rat] 			= "rat",
	[clsid.rat_s]			= "rat",
	[clsid.bloodsucker_s] 	= "bloodsucker",
	[clsid.boar_s] 			= "boar",
	[clsid.burer_s] 		= "burer",
	[clsid.chimera_s]		= "chimera",
	[clsid.controller_s]	= "controller",
	[clsid.dog_s]			= "dog",
	[clsid.flesh_s]			= "flesh",
	[clsid.gigant_s]		= "gigant",
	[clsid.psy_dog_s]		= "psy_dog",
	[clsid.psy_dog_phantom_s] = "psy_dog",
	[clsid.pseudodog_s]		= "pseudodog",
	[clsid.snork_s]			= "snork",
	[clsid.tushkano_s]		= "tushkano",
	[clsid.cat_s]			= "cat",
	[clsid.fracture_s]		= "fracture",
	[clsid.zombie_s]		= "zombie"
}
local monster_kind_to_name = {
	["SM_KARLIK"]			= "karlik",
	["SM_PSYSUCKER"]		= "psysucker",
	["SM_LURKER"]			= "lurker",
    ["SM_POLTER_G"]			= "poltergeist",
	["SM_PYRO_G"]			= "pyrogeist",
	["SM_PSEUDO_G"]			= "pseudogeist"
}
local function GetMutantName(obj)
    local sec = type(obj.section) == "function" and obj:section() or obj:section_name()
    local kind = SYS_GetParam(0, sec, "kind")
    local cls = obj:clsid()
    return monster_kind_to_name[kind] or monster_clsid_to_name[cls]
end

local function get_obj_screen_pos(obj)
	local pos = utils_obj.safe_bone_pos(obj, "bip01_head") or obj:position()
	local vec = pos and game.world2ui(vector():set(pos.x, pos.y, pos.z), false)
	if (vec and (vec.x ~= -9999) and (vec.y ~= 0)) then
		return vec
	end
	return nil
end

local function hui_dyn_scale_by_dist(dist)
	return 1
end

local function hui_get_current_fov()
	if device and type(device) == "function" then
		local dev = device()
		if dev and dev.fov ~= nil then
			return dev.fov
		end
	end
	if db and db.actor and db.actor.fov then
		local ok, v = pcall(function()
			return db.actor:fov()
		end)
		if ok and v ~= nil then
			return v
		end
	end
	return nil
end

local function hui_get_fov_factor()
	local fov = hui_get_current_fov()
	if not fov then
		return 1
	end
	if fov_ref == nil then
		fov_ref = fov
	end
	if fov > fov_ref then
		fov_ref = fov
	end
	if fov_ref < 1 then
		return 1
	end
	local k = fov / fov_ref
	if k < FOV_FACTOR_MIN then
		k = FOV_FACTOR_MIN
	elseif k > FOV_FACTOR_MAX then
		k = FOV_FACTOR_MAX
	end

	-- Apply weight: 0 = no compensation, 1 = full compensation, >1 = over-compensation
	if FOV_COMP_WEIGHT ~= 1 then
		k = 1.0 + (k - 1.0) * FOV_COMP_WEIGHT
	end

	return k
end

local function hui_head_y_offset_by_dist(dist)
	local near_dist = 1
	local far_dist = 100
	local near_off = 0.2
	local far_off = -1

	if not dist or dist <= near_dist then
		return near_off
	end
	if dist >= far_dist then
		return far_off
	end

	local t = (dist - near_dist) / (far_dist - near_dist)
	return near_off + ((far_off - near_off) * t)
end

local function hui_dyn_alpha_by_dist(dist)
	local dist_near = read_hui_setting_number("dyn_dist_near", 2)
	local dist_far = read_hui_setting_number("dyn_dist_far", 400)
	local a_near = read_hui_setting_number("dyn_alpha_near", 255)
	local a_far = read_hui_setting_number("dyn_alpha_far", 70)

	dist_near = math.max(dist_near, 0.01)
	dist_far = math.max(dist_far, dist_near + 0.01)

	if not dist or dist <= dist_near then
		return a_near
	end
	if dist >= dist_far then
		return a_far
	end

	local t = (dist - dist_near) / (dist_far - dist_near)
	if t < 0 then
		t = 0
	elseif t > 1 then
		t = 1
	end

	return a_near + ((a_far - a_near) * t)
end

local function hui_get_text_font()
	if GetFontLetterica16Russian then
		return GetFontLetterica16Russian()
	end
	if GetFontMedium then
		return GetFontMedium()
	end
	if GetFontSmall then
		return GetFontSmall()
	end
	return nil
end

local function hui_get_sub_font()
	return hui_get_text_font()
end

local function hui_apply_text_style(wnd, a, r, g, b, font)
	if not wnd then
		return
	end
	if font and wnd.SetFont then
		wnd:SetFont(font)
	end
	if wnd.SetTextColor then
		wnd:SetTextColor(GetARGB(a, r, g, b))
	end
end

local function hui_apply_texture_alpha(wnd, a)
	if wnd and wnd.SetTextureColor then
		wnd:SetTextureColor(GetARGB(a, 255, 255, 255))
	end
end

local function hui_apply_progress_style(wnd)
	if not wnd then
		return
	end
	if wnd.UseColor then
		wnd:UseColor(false)
	end
	if wnd.ShowBackground then
		wnd:ShowBackground(true)
	end
end

local function hui_apply_layout(ele, s)
	local w = MARKER_W
	local h = MARKER_H
	local root_sz = vector2():set(w, h)
	ele.marker:SetWndSize(root_sz)
	ele.marker_zoom:SetWndSize(root_sz)

	ele.text1:SetWndPos(vector2():set(0, -16))
	ele.text1_zoom:SetWndPos(vector2():set(0, -16))
	ele.text1:SetWndSize(vector2():set(w, 16))
	ele.text1_zoom:SetWndSize(vector2():set(w, 16))
	if ele.text1_sh and ele.text1_sh_zoom then
		ele.text1_sh:SetWndPos(vector2():set(1, -15))
		ele.text1_sh_zoom:SetWndPos(vector2():set(1, -15))
		ele.text1_sh:SetWndSize(vector2():set(w, 16))
		ele.text1_sh_zoom:SetWndSize(vector2():set(w, 16))
	end

	ele.text2:SetWndPos(vector2():set(0, 0))
	ele.text2_zoom:SetWndPos(vector2():set(0, 0))
	ele.text2:SetWndSize(vector2():set(w, 16))
	ele.text2_zoom:SetWndSize(vector2():set(w, 16))
	if ele.text2_sh and ele.text2_sh_zoom then
		ele.text2_sh:SetWndPos(vector2():set(1, 1))
		ele.text2_sh_zoom:SetWndPos(vector2():set(1, 1))
		ele.text2_sh:SetWndSize(vector2():set(w, 16))
		ele.text2_sh_zoom:SetWndSize(vector2():set(w, 16))
	end

	ele.text3:SetWndPos(vector2():set(0, 14))
	ele.text3_zoom:SetWndPos(vector2():set(0, 14))
	ele.text3:SetWndSize(vector2():set(w, 14))
	ele.text3_zoom:SetWndSize(vector2():set(w, 14))
	if ele.text3_sh and ele.text3_sh_zoom then
		ele.text3_sh:SetWndPos(vector2():set(1, 15))
		ele.text3_sh_zoom:SetWndPos(vector2():set(1, 15))
		ele.text3_sh:SetWndSize(vector2():set(w, 14))
		ele.text3_sh_zoom:SetWndSize(vector2():set(w, 14))
	end

	local hp_w = HP_BAR_W * s
	if hp_w < HP_BAR_MIN_W then
		hp_w = HP_BAR_MIN_W
	elseif hp_w > HP_BAR_MAX_W then
		hp_w = HP_BAR_MAX_W
	end
	local hp_h = 5
	local hp_x = (w - hp_w) * 0.5
	local hp_y = 30
	ele.hp_w = hp_w
	ele.hp_h = hp_h
	ele.hp:SetWndPos(vector2():set(hp_x, hp_y))
	ele.hp_zoom:SetWndPos(vector2():set(hp_x, hp_y))
	ele.hp_bg:SetWndPos(vector2():set(hp_x, hp_y))
	ele.hp_bg_zoom:SetWndPos(vector2():set(hp_x, hp_y))
	if ele.hp_shadow and ele.hp_shadow_zoom then
		ele.hp_shadow:SetWndPos(vector2():set(hp_x + 1, hp_y + 1))
		ele.hp_shadow_zoom:SetWndPos(vector2():set(hp_x + 1, hp_y + 1))
		ele.hp_shadow:SetWndSize(vector2():set(hp_w, hp_h))
		ele.hp_shadow_zoom:SetWndSize(vector2():set(hp_w, hp_h))
	end
	ele.hp:SetWndSize(vector2():set(hp_w, hp_h))
	ele.hp_zoom:SetWndSize(vector2():set(hp_w, hp_h))
end

local function hui_get_name_rgb_by_relation(rel)
	if game_object and rel ~= nil then
		if game_object.enemy ~= nil and rel == game_object.enemy then
			return 255, 80, 80
		end
		if game_object.friend ~= nil and rel == game_object.friend then
			return 80, 255, 80
		end
	end
	return 220, 200, 150
end

local function hui_get_faction_rgb_by_community(comm)
	if not comm then
		return 180, 180, 180
	end
	if comm == "stalker" then
		return 255, 255, 0
	end
	if comm == "csky" then
		return 0, 200, 255
	end
	if comm == "dolg" then
		return 255, 100, 100
	end
	if comm == "freedom" then
		return 135, 240, 110
	end
	if comm == "killer" then
		return 50, 100, 200
	end
	if comm == "army" then
		return 90, 120, 60
	end
	if comm == "ecolog" then
		return 230, 140, 10
	end
	if comm == "monolith" then
		return 150, 40, 200
	end
	if comm == "renegade" or comm == "renegades" then
		return 150, 30, 30
	end
	if comm == "greh" or comm == "sin" then
		return 200, 30, 0
	end
	if comm == "isg" or comm == "unisg" then
		return 0, 135, 60
	end
	if comm == "zombied" or comm == "zombies" then
		return 0, 0, 0
	end
	if comm == "trader" then
		return 255, 255, 255
	end
	return 180, 180, 180
end

local function hui_apply_style(ele, s, dist, rel, comm)
	local a = hui_dyn_alpha_by_dist(dist)

	hui_apply_texture_alpha(ele.marker, a)
	hui_apply_texture_alpha(ele.marker_zoom, a)
	if ele.hp_bg and ele.hp_bg_zoom then
		hui_apply_texture_alpha(ele.hp_bg, a)
		hui_apply_texture_alpha(ele.hp_bg_zoom, a)
		if ele.hp_bg.SetTextureColor then
			ele.hp_bg:SetTextureColor(GetARGB(a, 25, 25, 25))
		end
		if ele.hp_bg_zoom.SetTextureColor then
			ele.hp_bg_zoom:SetTextureColor(GetARGB(a, 25, 25, 25))
		end
	end
	if ele.hp_shadow and ele.hp_shadow_zoom then
		hui_apply_texture_alpha(ele.hp_shadow, a)
		hui_apply_texture_alpha(ele.hp_shadow_zoom, a)
		if ele.hp_shadow.SetTextureColor then
			ele.hp_shadow:SetTextureColor(GetARGB(a, 0, 0, 0))
		end
		if ele.hp_shadow_zoom.SetTextureColor then
			ele.hp_shadow_zoom:SetTextureColor(GetARGB(a, 0, 0, 0))
		end
	end
	hui_apply_texture_alpha(ele.hp, a)
	hui_apply_texture_alpha(ele.hp_zoom, a)

	local name_font = hui_get_text_font()
	local sub_font = hui_get_sub_font()
	local nr, ng, nb = hui_get_name_rgb_by_relation(rel)
	local fr, fg, fb = hui_get_faction_rgb_by_community(comm)
	if ele.text1_sh and ele.text1_sh_zoom then
		hui_apply_text_style(ele.text1_sh, a, 0, 0, 0, name_font)
		hui_apply_text_style(ele.text1_sh_zoom, a, 0, 0, 0, name_font)
	end
	if ele.text2_sh and ele.text2_sh_zoom then
		hui_apply_text_style(ele.text2_sh, a, 0, 0, 0, name_font)
		hui_apply_text_style(ele.text2_sh_zoom, a, 0, 0, 0, name_font)
	end
	if ele.text3_sh and ele.text3_sh_zoom then
		hui_apply_text_style(ele.text3_sh, a, 0, 0, 0, sub_font)
		hui_apply_text_style(ele.text3_sh_zoom, a, 0, 0, 0, sub_font)
	end
	if ele.text1 and ele.text1_zoom then
		hui_apply_text_style(ele.text1, a, 255, 127, 0, name_font)
		hui_apply_text_style(ele.text1_zoom, a, 255, 127, 0, name_font)
	end
	hui_apply_text_style(ele.text2, a, nr, ng, nb, name_font)
	hui_apply_text_style(ele.text2_zoom, a, nr, ng, nb, name_font)
	hui_apply_text_style(ele.text3, a, fr, fg, fb, sub_font)
	hui_apply_text_style(ele.text3_zoom, a, fr, fg, fb, sub_font)
end

local function hui_world2ui_px(pos)
	if not pos then
		return nil
	end
	local vec = game.world2ui(vector():set(pos.x, pos.y, pos.z), false)
	if not (vec and (vec.x ~= -9999) and (vec.y ~= 0)) then
		return nil
	end

	local sw = 1024
	local sh = 768
	if device and type(device) == "function" then
		local dev = device()
		if dev and dev.width and dev.height then
			sw = dev.width
			sh = dev.height
		end
	end

	local x = vec.x
	local y = vec.y
	hui_debug_raw_x = x
	hui_debug_raw_y = y
	hui_debug_mode = "raw"
	hui_debug_sw = sw
	hui_debug_sh = sh

	if x >= 0 and x <= 1.5 and y >= 0 and y <= 1.5 then
		hui_debug_mode = "01"
		x = x * sw
		y = y * sh
	elseif x >= -1.5 and x <= 1.5 and y >= -1.5 and y <= 1.5 then
		hui_debug_mode = "11"
		x = (x + 1) * 0.5 * sw
		y = (y + 1) * 0.5 * sh
	elseif x > -sw and x < sw and y > -sh and y < sh and (x < 0 or y < 0) then
		hui_debug_mode = "center"
		x = x + (sw * 0.5)
		y = y + (sh * 0.5)
	else
		hui_debug_mode = "px"
	end

	return vector2():set(x, y)
end

local function hui_is_target_allowed(npc)
	if (npc:clsid() == clsid.crow) then
		return nil
	end

	if not (IsStalker(npc) or IsMonster(npc)) then
		return nil
	end

	if not npc:alive() then
		return nil
	end

	if IsStalker(npc) and show_mode == 1 and npc:relation(db.actor) < game_object.enemy then
		return nil
	end

	local dist = math.sqrt(npc:position():distance_to_sqr(db.actor:position()))
	if dist > hui_range then
		return nil
	end

	if require_los and not db.actor:see(npc) then
		return nil
	end

	return dist
end

local function hui_set_target(npc)
	local dist = hui_is_target_allowed(npc)
	if not dist then
		return false
	end

	target_dist = dist
	target_faction = nil
	target_community = nil
	target_relation = nil
	if IsMonster(npc) then
		target_name = GetMutantName(npc) or "???"
		target_relation = game_object and game_object.enemy or nil
	elseif IsStalker(npc) then
		target_name = npc:character_name()
		target_community = character_community(npc)
		target_faction = target_community and game.translate_string(target_community) or nil
		if npc.relation and db and db.actor then
			local ok, rel = pcall(function()
				return npc:relation(db.actor)
			end)
			if ok then
				target_relation = rel
			end
		end
	else
		target_name = "???"
	end

	return true
end

local function hui_pick_target()
	return level.get_target_obj and level.get_target_obj() or nil

	--[[ временно выключено: радиус вокруг прицела
	if not (db and db.actor and db.actor:alive()) then
		return nil
	end
	if not (level and (level.get_target_obj or level.iterate_nearest)) then
		return nil
	end

	if not (device and type(device) == "function") then
		return level.get_target_obj and level.get_target_obj() or nil
	end

	local dev = device()
	if not (dev and dev.width and dev.height) then
		return level.get_target_obj and level.get_target_obj() or nil
	end

	local center_x = dev.width * 0.5
	local center_y = dev.height * 0.5
	local radius = crosshair_radius_px or 0
	if radius < 1 then
		return level.get_target_obj and level.get_target_obj() or nil
	end
	local radius2 = radius * radius

	if level.get_target_obj then
		local direct = level.get_target_obj()
		if direct then
			local dist = hui_is_target_allowed(direct)
			if dist then
				local vec = get_obj_screen_pos(direct)
				if vec then
					local dx = vec.x - center_x
					local dy = vec.y - center_y
					local d2 = (dx * dx) + (dy * dy)
					if d2 <= radius2 then
						return direct
					end
				end
			end
		end
	end

	if not (level and level.iterate_nearest) then
		return nil
	end

	local best_obj = nil
	local best_screen_d2 = nil
	local actor_pos = db.actor:position()

	local ok = pcall(level.iterate_nearest, actor_pos, hui_range, function(obj)
		if not obj then
			return false
		end

		local dist = hui_is_target_allowed(obj)
		if not dist then
			return false
		end

		local vec = get_obj_screen_pos(obj)
		if not vec then
			return false
		end

		local dx = vec.x - center_x
		local dy = vec.y - center_y
		local d2 = (dx * dx) + (dy * dy)
		if d2 <= radius2 and (best_screen_d2 == nil or d2 < best_screen_d2) then
			best_screen_d2 = d2
			best_obj = obj
			if d2 <= 1 then
				return true
			end
		end

		return false
	end)

	if not ok then
		return level.get_target_obj and level.get_target_obj() or nil
	end

	return best_obj
	]]
end

function hui_actor_on_update(delta)
	local ok, accum, last = hui_should_tick(hui_pick_accum_ms, hui_last_pick_ms, delta, hui_update_ms)
	hui_pick_accum_ms = accum
	hui_last_pick_ms = last
	if not ok then
		return
	end

	for id,_ in pairs(target_storage) do
		target_storage[id] = nil
	end

	local obj = hui_pick_target()
	if obj and hui_set_target(obj) then
		target_storage[obj:id()] = true
	end

	hui_ui_ensure()
end

local HUI_UI = nil

function hui_ui_ensure()
	if (HUI_UI == nil) then
		HUI_UI = hui_ui()
		get_hud():AddDialogToRender(HUI_UI)
	end
end

local function hui_ui_remove()
	if (HUI_UI ~= nil) then
		get_hud():RemoveDialogToRender(HUI_UI)
		HUI_UI = nil
	end
end

local function hui_ui_update()
	if (HUI_UI ~= nil) then
		HUI_UI:Update(true)
	end
end

class "hui_ui" (CUIScriptWnd)

function hui_ui:__init() super()
	self:InitControls()
end

function hui_ui:__finalize()
end

function hui_ui:InitControls()
	self:SetAutoDelete(true)
	self:SetWndRect(Frect():set(0,0,1024,768))
	self.xml = CScriptXmlInit()
	self.xml:ParseFile("ui_hui_marker.xml")
	self.ele = {}

end

function hui_ui:Update(delta)
	local ok, accum, last = hui_should_tick(hui_ui_accum_ms, hui_last_ui_ms, delta, hui_update_ms)
	hui_ui_accum_ms = accum
	hui_last_ui_ms = last
	if not ok then
		return
	end
	local zoom_mode = axr_main.weapon_is_zoomed
	CUIScriptWnd.Update(self)
	for id,_ in pairs(target_storage) do
		local st = db.storage[id]
		if (st and st.object and hui_set_target(st.object)) then
			if (self.ele[id] == nil) then
				self.ele[id] = {}
				self.ele[id].marker = self.xml:InitStatic("marker",self)
				self.ele[id].marker_zoom = self.xml:InitStatic("marker_zoom",self)
				self.ele[id].hp_shadow = self.xml:InitStatic("marker:hp_shadow", self.ele[id].marker)
				self.ele[id].hp_shadow_zoom = self.xml:InitStatic("marker_zoom:hp_shadow", self.ele[id].marker_zoom)
				self.ele[id].hp_bg = self.xml:InitStatic("marker:hp_bg", self.ele[id].marker)
				self.ele[id].hp_bg_zoom = self.xml:InitStatic("marker_zoom:hp_bg", self.ele[id].marker_zoom)
				self.ele[id].hp = self.xml:InitStatic("marker:hp", self.ele[id].marker)
				self.ele[id].hp_zoom = self.xml:InitStatic("marker_zoom:hp", self.ele[id].marker_zoom)
				self.ele[id].text1_sh = self.xml:InitTextWnd("marker:st_dist_sh",self.ele[id].marker)
				self.ele[id].text1_sh_zoom = self.xml:InitTextWnd("marker_zoom:st_dist_sh",self.ele[id].marker_zoom)
				self.ele[id].text1 = self.xml:InitTextWnd("marker:st_dist",self.ele[id].marker)
				self.ele[id].text1_zoom = self.xml:InitTextWnd("marker_zoom:st_dist",self.ele[id].marker_zoom)
				self.ele[id].text2_sh = self.xml:InitTextWnd("marker:npc_name_sh",self.ele[id].marker)
				self.ele[id].text2_sh_zoom = self.xml:InitTextWnd("marker_zoom:npc_name_sh",self.ele[id].marker_zoom)
				self.ele[id].text2 = self.xml:InitTextWnd("marker:npc_name",self.ele[id].marker)
				self.ele[id].text2_zoom = self.xml:InitTextWnd("marker_zoom:npc_name",self.ele[id].marker_zoom)
				self.ele[id].text3_sh = self.xml:InitTextWnd("marker:npc_faction_sh",self.ele[id].marker)
				self.ele[id].text3_sh_zoom = self.xml:InitTextWnd("marker_zoom:npc_faction_sh",self.ele[id].marker_zoom)
				self.ele[id].text3 = self.xml:InitTextWnd("marker:npc_faction",self.ele[id].marker)
				self.ele[id].text3_zoom = self.xml:InitTextWnd("marker_zoom:npc_faction",self.ele[id].marker_zoom)
			end
			
			local vec = self:GetScreenCoordinates(st.object, target_dist)

			if (vec) then
				local dyn_s = 1
				hui_apply_layout(self.ele[id], dyn_s)
				hui_apply_style(self.ele[id], dyn_s, target_dist, target_relation, target_community)
				local px = vec.x - (MARKER_W * 0.5)
				local py = vec.y - MARKER_H
				local jitter = (hui_update_ms and hui_update_ms > 0) and 1 or 0
				if jitter > 0 and self.ele[id].last_px_x ~= nil and self.ele[id].last_px_y ~= nil then
					local dx = px - self.ele[id].last_px_x
					local dy = py - self.ele[id].last_px_y
					if dx < 0 then
						dx = -dx
					end
					if dy < 0 then
						dy = -dy
					end
					if dx <= jitter and dy <= jitter then
						px = self.ele[id].last_px_x
						py = self.ele[id].last_px_y
					end
				end
				px = math.floor(px + 0.5)
				py = math.floor(py + 0.5)
				self.ele[id].last_px_x = px
				self.ele[id].last_px_y = py
				local pos = vector2():set(px, py)
				self.ele[id].marker:SetWndPos(pos)
				self.ele[id].marker_zoom:SetWndPos(pos)
				self.ele[id].hp_shadow:Show(true)
				self.ele[id].hp_shadow_zoom:Show(true)
				self.ele[id].hp_bg:Show(true)
				self.ele[id].hp_bg_zoom:Show(true)
				self.ele[id].hp:Show(true)
				self.ele[id].hp_zoom:Show(true)
				if self.ele[id].hp_shadow.SetTextureColor then
					self.ele[id].hp_shadow:SetTextureColor(GetARGB(160, 0, 0, 0))
				end
				if self.ele[id].hp_shadow_zoom.SetTextureColor then
					self.ele[id].hp_shadow_zoom:SetTextureColor(GetARGB(160, 0, 0, 0))
				end
				local hp = nil
				if st.object.health ~= nil then
					if type(st.object.health) == "function" then
						hp = st.object:health()
					elseif type(st.object.health) == "number" then
						hp = st.object.health
					end
				end
				if hp == nil then
					hp = 1
				end
				if hp < 0 then
					hp = 0
				elseif hp > 1 then
					hp = 1
				end
				local hp_w = self.ele[id].hp_w or HP_BAR_W
				local hp_h = self.ele[id].hp_h or 5
				local fill_w = math.floor((hp_w * hp) + 0.5)
				self.ele[id].hp_shadow:SetWndSize(vector2():set(hp_w, hp_h))
				self.ele[id].hp_shadow_zoom:SetWndSize(vector2():set(hp_w, hp_h))
				self.ele[id].hp_bg:SetWndSize(vector2():set(hp_w, hp_h))
				self.ele[id].hp_bg_zoom:SetWndSize(vector2():set(hp_w, hp_h))
				self.ele[id].hp:SetWndSize(vector2():set(fill_w, hp_h))
				self.ele[id].hp_zoom:SetWndSize(vector2():set(fill_w, hp_h))

				if show_distance then
					self.ele[id].text1_sh:Show(true)
					self.ele[id].text1_sh_zoom:Show(true)
					self.ele[id].text1:Show(true)
					self.ele[id].text1_zoom:Show(true)
					local meters = math.floor(target_dist + 0.5)
					self.ele[id].text1_sh:SetText(string.format("%i m", meters))
					self.ele[id].text1_sh_zoom:SetText(string.format("%i m", meters))
					self.ele[id].text1:SetText(string.format("%i m", meters))
					self.ele[id].text1_zoom:SetText(string.format("%i m", meters))
				else
					self.ele[id].text1_sh:SetText("")
					self.ele[id].text1_sh_zoom:SetText("")
					self.ele[id].text1:SetText("")
					self.ele[id].text1_zoom:SetText("")
					self.ele[id].text1_sh:Show(false)
					self.ele[id].text1_sh_zoom:Show(false)
					self.ele[id].text1:Show(false)
					self.ele[id].text1_zoom:Show(false)
				end

				if show_name then
					self.ele[id].text2_sh:Show(true)
					self.ele[id].text2_sh_zoom:Show(true)
					self.ele[id].text2:Show(true)
					self.ele[id].text2_zoom:Show(true)
					self.ele[id].text3_sh:Show(true)
					self.ele[id].text3_sh_zoom:Show(true)
					self.ele[id].text3:Show(true)
					self.ele[id].text3_zoom:Show(true)
					local faction_text = target_faction or ""
					if faction_text ~= "" then
						faction_text = "[" .. faction_text .. "]"
					end
					self.ele[id].text2_sh:SetText(target_name or "")
					self.ele[id].text2_sh_zoom:SetText(target_name or "")
					self.ele[id].text2:SetText(target_name or "")
					self.ele[id].text2_zoom:SetText(target_name or "")
					self.ele[id].text3_sh:SetText(faction_text)
					self.ele[id].text3_sh_zoom:SetText(faction_text)
					self.ele[id].text3:SetText(faction_text)
					self.ele[id].text3_zoom:SetText(faction_text)
				else
					self.ele[id].text2_sh:SetText("")
					self.ele[id].text2_sh_zoom:SetText("")
					self.ele[id].text2:SetText("")
					self.ele[id].text2_zoom:SetText("")
					self.ele[id].text2_sh:Show(false)
					self.ele[id].text2_sh_zoom:Show(false)
					self.ele[id].text2:Show(false)
					self.ele[id].text2_zoom:Show(false)
					self.ele[id].text3_sh:SetText("")
					self.ele[id].text3_sh_zoom:SetText("")
					self.ele[id].text3:SetText("")
					self.ele[id].text3_zoom:SetText("")
					self.ele[id].text3_sh:Show(false)
					self.ele[id].text3_sh_zoom:Show(false)
					self.ele[id].text3:Show(false)
					self.ele[id].text3_zoom:Show(false)
				end

				if zoom_mode then
					self.ele[id].marker_zoom:Show(true)			
					self.ele[id].marker:Show(false)	
				else	
					self.ele[id].marker:Show(true)	
					self.ele[id].marker_zoom:Show(false)	
				end	
			else
				self.ele[id].last_px_x = nil
				self.ele[id].last_px_y = nil
				self.ele[id].text1:SetText("")
				self.ele[id].text1_zoom:SetText("")
				self.ele[id].text2:SetText("")
				self.ele[id].text2_zoom:SetText("")
				self.ele[id].text3:SetText("")
				self.ele[id].text3_zoom:SetText("")
				self.ele[id].text1_sh:SetText("")
				self.ele[id].text1_sh_zoom:SetText("")
				self.ele[id].text2_sh:SetText("")
				self.ele[id].text2_sh_zoom:SetText("")
				self.ele[id].text3_sh:SetText("")
				self.ele[id].text3_sh_zoom:SetText("")
				self.ele[id].text1:Show(false)
				self.ele[id].text1_zoom:Show(false)
				self.ele[id].text2:Show(false)
				self.ele[id].text2_zoom:Show(false)
				self.ele[id].text3:Show(false)
				self.ele[id].text3_zoom:Show(false)
				self.ele[id].text1_sh:Show(false)
				self.ele[id].text1_sh_zoom:Show(false)
				self.ele[id].text2_sh:Show(false)
				self.ele[id].text2_sh_zoom:Show(false)
				self.ele[id].text3_sh:Show(false)
				self.ele[id].text3_sh_zoom:Show(false)
				self.ele[id].hp:Show(false)
				self.ele[id].hp_zoom:Show(false)
				self.ele[id].hp_bg:Show(false)
				self.ele[id].hp_bg_zoom:Show(false)
				self.ele[id].hp_shadow:Show(false)
				self.ele[id].hp_shadow_zoom:Show(false)
				self.ele[id].marker:Show(false)
				self.ele[id].marker_zoom:Show(false)
			end
		else
			target_storage[id] = nil
		end
	end
	
	for id,_ in pairs(self.ele) do
		if (target_storage[id] ~= true) then
			self.ele[id].text1:SetText("")
			self.ele[id].text1_zoom:SetText("")
			self.ele[id].text2:SetText("")
			self.ele[id].text2_zoom:SetText("")
			self.ele[id].text3:SetText("")
			self.ele[id].text3_zoom:SetText("")
			self.ele[id].text1_sh:SetText("")
			self.ele[id].text1_sh_zoom:SetText("")
			self.ele[id].text2_sh:SetText("")
			self.ele[id].text2_sh_zoom:SetText("")
			self.ele[id].text3_sh:SetText("")
			self.ele[id].text3_sh_zoom:SetText("")
			self.ele[id].text1:Show(false)
			self.ele[id].text1_zoom:Show(false)
			self.ele[id].text2:Show(false)
			self.ele[id].text2_zoom:Show(false)
			self.ele[id].text3:Show(false)
			self.ele[id].text3_zoom:Show(false)
			self.ele[id].text1_sh:Show(false)
			self.ele[id].text1_sh_zoom:Show(false)
			self.ele[id].text2_sh:Show(false)
			self.ele[id].text2_sh_zoom:Show(false)
			self.ele[id].text3_sh:Show(false)
			self.ele[id].text3_sh_zoom:Show(false)
			self.ele[id].hp:Show(false)
			self.ele[id].hp_zoom:Show(false)
			self.ele[id].hp_bg:Show(false)
			self.ele[id].hp_bg_zoom:Show(false)
			self.ele[id].hp_shadow:Show(false)
			self.ele[id].hp_shadow_zoom:Show(false)
			self.ele[id].marker:Show(false)
			self.ele[id].marker_zoom:Show(false)
			self.ele[id] = nil
		end
	end
end

function hui_ui:GetScreenCoordinates(obj, dist)
	local pos = utils_obj.safe_bone_pos(obj, "bip01_head") or obj:position()
	if not pos then
		return nil
	end
	
	-- Base offset scaled by FOV (to keep it somewhat consistent on screen)
	local base_off = hui_head_y_offset_by_dist(dist)
	local fov_k = hui_get_fov_factor()
	
	-- Total offset: scaled base + direct bias
	-- Applying bias separately makes it predictable for the user regardless of zoom
	local off = (base_off * fov_k) + (HEAD_Y_OFFSET_BIAS or 0)
	
	if off ~= 0 then
		pos = vector():set(pos.x, pos.y + off, pos.z)
	end
	return hui_world2ui_px(pos)
end


---------------------------------------------------------
-- Callbacks
---------------------------------------------------------
local function on_option_change()
	hui_ui_remove()
	hui_range = mcm_get("hui/range") or read_hui_setting_number("range", 500)
	hui_scale = 1
	hui_ypos = 0
	HEAD_Y_OFFSET_BIAS = mcm_get("hui/head_y_offset") or read_hui_setting_number("head_y_offset", 0.2)
	FOV_FACTOR_MIN = mcm_get("hui/fov_factor_min") or read_hui_setting_number("fov_factor_min", 0.1)
	FOV_FACTOR_MAX = mcm_get("hui/fov_factor_max") or read_hui_setting_number("fov_factor_max", 2)
	FOV_COMP_WEIGHT = mcm_get("hui/fov_comp_weight") or read_hui_setting_number("fov_comp_weight", 1.3)
	HP_BAR_W = mcm_get("hui/hp_bar_w") or read_hui_setting_number("hp_bar_w", 70)
	HP_BAR_MIN_W = mcm_get("hui/hp_bar_min_w") or read_hui_setting_number("hp_bar_min_w", 5)
	HP_BAR_MAX_W = mcm_get("hui/hp_bar_max_w") or read_hui_setting_number("hp_bar_max_w", 50)
	show_distance = mcm_get("hui/show_distance")
	if show_distance == nil then
		show_distance = read_hui_setting_bool("show_distance", true)
	end
	show_name = mcm_get("hui/show_name")
	if show_name == nil then
		show_name = read_hui_setting_bool("show_name", true)
	end
	show_mode = mcm_get("hui/show_mode") or read_hui_setting_number("show_mode", 2)
	require_los = mcm_get("hui/require_los")
	if require_los == nil then
		require_los = read_hui_setting_bool("require_los", true)
	end
	show_icon = mcm_get("hui/show_icon")
	if show_icon == nil then
		show_icon = read_hui_setting_bool("show_icon", true)
	end
	hui_update_ms = hui_normalize_update_ms(mcm_get("hui/update_ms") or read_hui_setting_number("update_ms", 17))
	hui_last_pick_ms = nil
	hui_last_ui_ms = nil
	hui_pick_accum_ms = 0
	hui_ui_accum_ms = 0
	hui_ui_ensure()
end

function actor_on_first_update()
	hui_ui_ensure()
end

function actor_on_net_destroy()
	hui_ui_remove()
end

function update_hud_on_show_hide()
	hui_ui_update()
end


function on_game_start()
	RegisterScriptCallback("actor_on_first_update",actor_on_first_update)
	RegisterScriptCallback("actor_on_net_destroy",actor_on_net_destroy)
	RegisterScriptCallback("GUI_on_show",update_hud_on_show_hide)
	RegisterScriptCallback("GUI_on_hide",update_hud_on_show_hide)
	RegisterScriptCallback("actor_on_update",hui_actor_on_update)
	RegisterScriptCallback("on_option_change", on_option_change)
end
